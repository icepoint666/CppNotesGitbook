# C++ 垃圾回收\(gc\)

### C++垃圾回收理念

C++其实是没有自己实现垃圾回收的

GC的理念是：绝对可订制，默认不回收任何垃圾的GC，**所以想要什么样的GC，自己写就可以了**

C++资源管理的本质思路：

1. 统一资源回收也是需要成本的，C++相当于将资源回收的成本摊销到程序的各个角落，就不需要担心集中资源回收导致的性能凹陷了
2. c++采用与内存资源等同视之的方式管理操作系统资源，即大家都知道的raii

### C++垃圾回收的解决方案

* RAII
  * RAII并不能解决所有C++中的垃圾回收机制：参照灵剑的回答：[https://www.zhihu.com/question/308638046](https://www.zhihu.com/question/308638046)
* 引用计数（智能指针也是这个原理）
* 标记扫描（内存池的思路），类似于手动实现一个GC
  * 做法就是 将所有用到的对象保存在内存池里，**然后在需要的时候通过标记·扫描算法回收所有没有被用到的对象。**
  * 但是这个collect方法会存在很多问题，用户不知道什么时候回收，全堆扫描开销太大，怎么做到多线程安全...解决的问题和托管堆GC是一样的，还不如使用一个**托管内存的语言**
  * 如果真的像实现一个JVM那样的一个完备的垃圾回收，如果可以，可以用Java（:D

**总的来说：C++的垃圾回收没有一种绝对通用于整个语言的方案，只能不同场景不同业务下不同实现**

### C++资源问题总结

c++资源问题（刨除缺页等性能问题）总结起来也是两句话

1. 野指针与内存泄露，包括线程安全和异常安全什么的，挺复杂的
2. 在使用了c++为了应对第一个问题给出的智能指针方案后，产生的混乱问题

### 关于野指针的问题

什么是野指针，野指针一般由两种原因造成：

* 一个是定义的指针没有初始化，指针指向随机值；
* 二是申请了内存，内存释放掉了，但是指针没有清空，相当于指向了无效的地址

避免野指针：

* 初始化；
* 内存释放后，要把指针清空，赋值为NULL。

### 关于智能指针

c++的智能指针是有语义的，什么东西能share，什么东西不能share，share和copy的关系等等，其实是个很复杂的问题，shared\_ptr满天飞的代码，基本上是设计出了问题

总体而言

* share/weak是一对
* unique/裸指针是一对。

**当你还没搞清楚你要选哪一种的时候，你应该默认选择unique/裸指针**

因为多数时候，资源应该有一个明确的归属，而不应该“共享”，而一个对象所有权被共享，意味着这个对象代表的资源什么时候被回收，你根本不关心，其实这种情况是不多的。

**在多线程的场景中，我们也经常使用share/weak**

这时候，我们常常表达的是近似unique/裸指针的语义，表现在代码层面就是单shared\_ptr+单或多weak\_ptr，这时候shared\_ptr除了管理资源，还多了一个mutex的职责，即主线程不是先停止子线程，而是先尝试回收资源，让子线程在下一次循环中，weak\_ptr发生lock失败，继而自觉退出。

链接：[https://www.zhihu.com/question/308638046/answer/608362953](https://www.zhihu.com/question/308638046/answer/608362953) 

