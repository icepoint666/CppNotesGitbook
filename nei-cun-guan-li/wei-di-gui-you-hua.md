# 尾递归优化

> 尾递归可以被优化为循环迭代，编译器会自动帮我们做！！写阶乘写成尾递归的模式会高效

[https://zhuanlan.zhihu.com/p/36587160](https://zhuanlan.zhihu.com/p/36587160)

### **普通**递归函数

要将尾递归，我们要先从递归讲起。首先选择一个最简单的例子——阶乘。以下是一个用普通递归形式写的用来计算 n 的阶乘的函数：

```cpp
function fact(n) {
    if (n <= 0) {
        return 1;
    } else {
        return n * fact(n - 1);
    }
}
```

当我们计算 fact\(6\) 的时候，会产生如下展开：

```cpp
6 * fact(5)
6 * (5 * fact(4))
6 * (5 * (4 * fact(3))))
// two thousand years later...
6 * (5 * (4 * (3 * (2 * (1 * 1)))))) // <= 最终的展开
```

注意了，到这里为止，程序做的仅仅还只是展开而已，并没有运算真正运运算，接下来才是运算：

```cpp
6 * (5 * (4 * (3 * (2 * 1)))))
6 * (5 * (4 * (3 * 2))))
6 * (5 * (4 * 6)))
// two thousand years later...
720 // <= 最终的结果
```

我们普通递归的问题在于展开的时候会产生非常大的中间缓存，而每一层的中间缓存都会占用我们宝贵的栈上空间，所有导致了当这个 n 很大的时候，栈上空间不足则会产生“爆栈”的情况。

那有没有一种方法能够避免这样的情况呢？那当然是有的，那就是我们这篇文章的主角——尾递归了。

### **尾递归函数**

我们以上面的阶乘函数为例，写成尾递归的形式：

```cpp
function fact(n, r) {
    if (n <= 0) {
        return 1 * r;
    } else {
        return fact(n - 1, r * n);
    }
}
```

我们像上面一个普通递归函数一样来展开和运算 fact\(6\)：

```cpp
fact(6, 1) // 1 是 fact(0) 的值，我们需要手动写一下
fact(5, 6)
fact(4, 30)
fact(3, 120)
fact(2, 360)
fact(1, 720)
720 // <= 最终的结果
```

跟上面的普通递归函数比起来，貌似尾递归函数因为在展开的过程中计算并且缓存了结果，

**尾递归函数依然还是递归函数，如果不优化依然跟普通递归函数一样会爆栈**

**不会爆栈是因为语言的编译器或者解释器所做了“尾递归优化”，才让它不会爆栈的。**

### **尾递归特点**

尾递归在普通尾调用的基础上，多出了2个特征：  
1. 在尾部调用的是函数自身 \(Self-called\)；  
2. 可通过优化，使得计算仅占用常量栈空间 \(Stack Space\)。

### 尾递归为什么可以优化

**首先要明确函数栈的目的：函数栈的目的是啥？是保持入口环境**

那么在什么情况下可以把这个入口环境给优化掉？入口环境没意义的情况下为啥要保持入口环境？尾递归，就恰好是这种情况。

因为**尾递归的情况下，我们保持这个函数的入口环境没意义，所以我们就可以把这个函数的调用栈给优化掉。**

### **手动用循环优化尾递归**

尾递归代码：

```cpp
function fact(n, r) { // <= 这里把 n, r 作为迭代变量提出来
    if (n <= 0) {
        return 1 * r; // <= 递归终止
    } else {
        return fact(n - 1, r * n); // <= 用迭代函数替代 fact。
    }
}
```

转换后得到的代码：

```cpp
function fact(_n, _r) { // <= _n, _r 用作初始化变量
    var n = _n;
    var r = _r; // <= 将原来的 n, r 变量提出来编程迭代变量
    function _fact(_n, _r) { // <= 迭代函数非常简单,就是更新迭代变量而已
        n = _n;
        r = _r;
    }
    _fact_loop: while (true) { // <= 生成一个迭代循环
        if (n <= 0) {
            return r;
        } else {
            _fact(n - 1, r * n); continue _fact_loop; // <= 执行迭代函数，并且进入下一次迭代
        }
    }
}
```

到这里，我们就已经将一个尾递归函数转换成循环迭代函数了。

