# C++序列化，protobuf

### 什么是序列化，为什么要序列化

程序员在编写应用程序的时候往往需要将程序的某些数据存储在内存中，然后将其写入某个文件或是将它传输到网络中的另一台计算机上以实现通讯。这个将 程序数据转化成能被存储并传输的格式的过程被称为“序列化”（Serialization），而它的逆过程则可被称为“反序列化” （Deserialization）。

序列化：将对象变成字节流的形式传出去。

反序列化：从字节流恢复成原来的对象。

简单来说，对象序列化通常用于**两个目的：**

（1） 将对象存储于硬盘上 ，便于以后反序列化使用

（2）在网络上传送对象的字节序列

序列化好处的**小例子**：神经网络模型

你有一个数据结构，里面存储的数据是经过很多其它数据通过非常复杂的算法生成的，由于数据量很大，算法又复杂，因此生成该数据结构所用数据的时间可能要很久 （也许几个小时，甚至几天），生成该数据结构后又要用作其它的计算，那么你在调试阶段，每次运行个程序，就光生成数据结构就要花上这么长的时间，无疑代价 是非常大的。如果你确定生成数据结构的算法不会变或不常变，那么就可以通过序列化技术生成数据结构数据存储到磁盘上，下次重新运行程序时只需要从磁盘上读 取该对象数据即可，所花费时间也就读一个文件的时间，可想而知是多么的快，节省了我们的开发时间。

### protobuf

Google Protocol Buffers \(GPB\)是Google内部使用的数据编码方式，旨在用来代替XML进行数据交换。可用于数据序列化与反序列化。主要特性有：

高效

语言中立\(Cpp, Java, Python\)

可扩展

**（1）protobuf支持的数据类型不是很丰富**

protobuf属于轻量级的，因此不能支持太多的数据类型，下面是protobuf支持的基本类型列表，一般都能满足需求，不过在选择方案之前，还是先看看是否都能支持，以免前功尽弃。同样该表也值得收藏，作为我们在定义类型时做参考。

double,float,int32,int64,uint32,uint64,bool,string等都还是支持的

**（2）protobuf不支持二维数组（指针），不支持STL容器序列化**

这个缺陷挺大，因为稍复杂点的数据结构或类结构里出现二维数组、二维指针和STL容器（set、list、map等）很频繁，但因为 protobuf简单的实现机制，只支持一维数组和指针（用repeated修饰符修饰），不能使用repeated repeated来支持二维数组， 也不支持STL，因此在选择该方案之前，一定 要确保你的数据结构里没有这些不支持的类型。

**（3）protobuf嵌套后会改变类名称**

protobuf支持类的嵌套，即在一个自定义类型中可以定义另一个自定义类型，但注意嵌套的自定义类型在经过protobuf处理后生成的类名称并不是你定义的类名称，而是加上了外层的类名称作为前缀，下面举一个简单的例子：

message DFA {

required int32 \_size =1;

message accept\_pair {

required boolis\_accept\_state =1;

required boolis\_strict\_end =2;

optional stringapp\_name =3;

}

repeated accept\_pair accept\_states =2;

}

那么嵌套中的accept\_pair 生成后的类不是accept\_pair 而是DFA\_accept\_pair 。如果不想改类名称，将accept\_pair 拿到外面与DFA平行定义即可。

