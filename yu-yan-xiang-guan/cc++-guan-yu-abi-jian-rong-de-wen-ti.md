# C/C++关于ABI兼容的问题

* 程序指令的逻辑发展历程
* 什么是ABI
* C与ABI兼容（C的一个优点）
* C++与ABI兼容
* ABI不兼容问题

### 

### 程序指令的逻辑发展历程

早期的程序，是流水账式的。没有函数，没有子过程，有行号，程序按照行号一行一行执行下去。

后来，有了**条件判断和无条件转向语句**，也就是if，goto这种东西，基础是**CPU当中的条件转向指令和无条件转向指令**

再后来，有了**子过程概念，**子过程是写在主程序结束语句之后的一小段程序，通过主程序当中的一条跳转命令跳转到其开始地址执行，在其末尾有一条返回命令，返回到主程序当中跳转过来的那个点。于是**CPU又增加了call指令和ret指令，用来保存和恢复程序计数器**

再后来出现了需要传递参数的子过程调用，也就是**函数**。不同的函数参数个数，类型，以及返回值类型都是不同的。因此，很难说通过再增加一个CPU指令来实现。**方法就是靠压栈**。通过将当前执行环境的现场（如CPU寄存器）压入堆栈进行保存，然后在CPU的寄存器里面放入函数所需的参数，完成函数的调用。哪个参数放在AX里面，哪个放在BX里面，函数返回值在哪个寄存器里面。

这个函数调用方和被调用方需要协商一致，这个对于CPU如何执行保证一致性的约定，就是ABI。

### 

### 什么是ABI

ABI: **Application Binary Interface**, 应用二进制接口

当你用一个库，里面必然存着很多信息（比如实际的机器码、函数表），**总得有一个规定说明他们存储的结构**（PE/dll，elf/so），这就是ABI的一部分。

本身这个ABI，表示的是二进制接口，也就是目标文件级别的接口统一、

它相当于是一个中间部分，由上面的程序经过编译器编译得到，然后运给底层CPU硬件执行

所以**ABI兼容主要涉及到两个层面的统一：编译器，硬件架构**

#### **1. 编译器层面 \(严格意义上不一定能算进ABI\)**

**名称修饰（name mangling）:** 调用二进制库中一个函数时，需要去查找函数表，因为C++允许重载， 两个函数可以同名但不同参数，所以**要把参数信息一起编码进去，**这个就是name mangling，这个函数名称信息一般存放在字符串表/符号表中。

这部分通常是编译器决定的，即同样是在Windows下，mingw和msvc编译出来的库里的函数可以有不同的名字，两者之间会因为mangling规则不同而无法相互调用。（这个name）

**调用转化（calling conversion）:**当你选择了一个函数，你还要知道**参数怎么传，返回值放哪里，栈由谁清理**。这个就是calling convension。

这个也是编译器决定的，但可以手动指定一些特别的调用约定，几个编译器之间只要支持就不会在这个地方发生兼容问题。

#### 2. 硬件架构层面

**不同的架构（如x86和arm，x86的32位/64位）有着不同的资源/寄存器**，也会导致calling convension的不同。相互之间机器码不能互相兼容，所以这个必然属于ABI的考量范围内。

### 

### C与ABI兼容

**C在同一操作系统内有统一ABI**

因为各主流的OS都以C作为系统API接口，所以在OS层面确定了**在同一系统内**C的ABI。

C的ABI兼容性，其实是由OS来制定并且推广的。对于**不同风格的OS**（例如说win-&gt;\*nix），其实**一样是不兼容的。**

\*\*\*\*

**本质：相当于是操作系统作为一个权威方，为各个编译器统一了一套在我这个操作系统的ABI规范**

C Compiler要是特立独行硬要用自己的接口规范，编译出来的程序只能自己和自己玩。

其他语言：操作系统没有定义对其他语言的接口规范，又没有其他人能提出一个有力服众的接口规范，操作系统没有定义对其他语言的接口规范，又没有其他人能提出一个有力服众的接口规范

**对于硬件不同还是没用**：C把**不同机器（硬件结构）的库混用**，理论上**也是不行的**，即使这个库不涉及系统调用。



### C++与ABI兼容

硬件兼容：

* 不同CPU寄存器数量都不一样，规定前四个参数用寄存器传递，万一空闲的寄存器只有三个怎么办？
* 规定64位以下的参数可以用寄存器传参，人家寄存器是32位的怎么办？16位的呢？
* 规定参数按顺序入栈，不对齐字节边界，万一人家寄存器不对齐字节边界就不能读取怎么办？

**编译器版本**可能也有关系：

例如： GCC 5.1 版本发布的libstdc++中，添加了包含`std::string`和`std::list`的新的实现方法的ABI

为了实现与现存代码兼容，libstdc++的库名没有进行修改，而且老的实现也依然保留着与新的实现并存。

并存实现是 让它们在链接之前（也就是链接时）就有了不同的名字，比如 新版本的`std::list<int>`被定义为了`std::__cxx11::list<int>`。也正是因为新的实现有不同的名字，使得新、旧实现能够在同一个库中并存。

造成的问题：当你升级GCC版本后，如果把整个代码都全部重新编译一遍，那么你基本上不会遇到ABI问题的。但是如果你还依赖于其他第三方编译出来的动态库，而它们是用老版本的GCC\(如：GCC 4.8\)编译出来的，那么就有可能会遇到ABI的问题



### ABI不兼容问题

当编译链接时遇到报错`undefined reference to "std::__cxx11 ***"`，那基本就是遇到了C++ ABI问题了

一般情况像前面说的GCC版本升级或者不匹配造成的ABI不兼容问题，在编译的时候添加一个定义`-D_GLIBCXX_USE_CXX11_ABI=0`就可以了。

一个例子：

一般如果一个库的开发者，不像开放source codes，那么就现在自己的环境下编译一个库.so或者.dll

将这个库**.so/.dll**以及头文件**.h**分发出去，往往为了适配硬件，所以还是会在不同机器上编译出win32,win64,linux32这些版本的

但是这样其实还是没有考虑到一个问题就是，库发布者 与 库使用者代码 编译时的**编译器的不一致**

同是gcc/g++：支持C++11的编译器版本与不支持C++11的编译器版本会有这个问题的存在

解决链接：[https://developers.redhat.com/blog/2015/02/05/gcc5-and-the-c11-abi/](https://developers.redhat.com/blog/2015/02/05/gcc5-and-the-c11-abi/)



链接：[https://www.zhihu.com/question/39148567/answer/280432289](https://www.zhihu.com/question/39148567/answer/280432289) 

