# 虚函数，虚继承内存模型

* 单继承内存模型
* 多继承内存模型
* 虚继承内存模型（菱形继承）（没有仔细看懂）

> [https://zhuanlan.zhihu.com/p/41309205](https://zhuanlan.zhihu.com/p/41309205)

**多态类型**就是指至少继承了一个虚函数的类型，继承者与被继承者都是多态类型

可以自己dump出内存中对象的内存模型，和类型的虚表的结构，使用g++导出继承结构的指令如下：

```text
$ g++ -fdump-class-hierarchy -c main.cpp
```

#### 总结：

* **虚函数地址**通过虚指针索引的虚函数表在运行时确定；
* 虚表中不仅储存了虚函数的地址，还储存了**类型RTTI的地址**、**距实际类型首地址偏移量offset\_to\_top**等信息；
* 虚函数的调用可能涉及到**`this`指针的变更**，需要**`Thunk`**等方式实现；
* 对于虚基类的派生类，虚基类的偏移量由实际类型决定，因此在运行时才可以确定虚基类的地址
* 在多态类型的构造和析构过程中，通过修改虚指针使其指向不同的虚表，可以实现在不同的阶段调用不同的虚函数；
* 对于虚继承的情况，由于同一类型虚表的虚表在不同具体类型中可以不同，在构造和析构时，需要通过`VTT`传递正确的虚表。

### 单继承内存模型

对于每一个多态类型，其所有的虚函数的地址都以一个表格的方式存放在一起

**示例1：普通继承**

```cpp
struct A
{
    int ax; // 成员变量
    virtual void f0() {}
    virtual void f1() {}
};

struct B : public A
{
    int bx; // 成员变量
    void f0() override {}; // 重写f0
};



```

它们的**对象模型**和**虚表模型**如下所示：

```text
struct A
 object                                            A VTable (不完整)
     0 - vptr_A -------------------------------->  +--------------+
     8 - int ax                                    |    A::f0()   |
sizeof(A): 16    align: 8                          +--------------+
                                                   |    A::f1()   |
                                                   +--------------+

struct B
 object                                         
     0 - struct A                                  B VTable (不完整)
     0 -   vptr_A ------------------------------>  +--------------+
     8 -   int ax                                  |    B::f0()   |
    12 - int bx                                    +--------------+
sizeof(A): 16    align: 8                          |    A::f1()   |
                                                   +--------------+
```

**示例2：加入虚函数**

如果类型`B`中出现了基类型`A`中没有的虚函数，新的虚函数将会被附加在虚函数表的最后，不会对与基类重合的部分造成影响。例如`B`中新增加了函数`f2()`，虚函数表变化如下：

```text
 struct B
 object                                         
     0 - struct A                                  B VTable (不完整)
     0 -   vptr_A ------------------------------>  +--------------+
     8 -   int ax                                  |    B::f0()   |
    12 - int bx                                    +--------------+
sizeof(A): 16    align: 8                          |    A::f1()   |
                                                   +--------------+
                                                   |    B::f2()   |
                                                   +--------------+
```

对于多态类型，除了要在运行时确定虚函数地址外，还需要提供运行时类型信息\(Run-Time Type Identification, RTTI\)的支持。一个显然的解决方案是，将类型信息的地址加入到虚表之中。为了避免虚函数表长度对其位置的影响，g++将它放在虚函数表的前，所示如下：

```text
 struct B                                          B VTable (不完整)
 object                                            +--------------+
     0 - struct A                                  |  RTTI for B  |
     0 -   vptr_A ------------------------------>  +--------------+
     8 -   int ax                                  |    B::f0()   |
    12 - int bx                                    +--------------+
sizeof(A): 16    align: 8                          |    A::f1()   |
                                                   +--------------+
                                                   |    B::f2()   |
                                                   +--------------+
```

现在的虚表中，不仅含有函数地址，还含有RTTI的地址，之后还会加入许多新项目。虚表中的每一项都称作一个实体\(entity\)。

**示例3：单链继承**

例如，`B`继承`A`，`C`继承`B`，它们的定义和内存模型如下所示：

```cpp
struct A
{
    int ax;
    virtual void f0() {}
};

struct B : public A
{
    int bx;
    virtual void f1() {}
};

struct C : public B
{
    int cx;
    void f0() override {}
    virtual void f2() {}
};
```

内存模型为

```text
                                                      C VTable（不完整)
struct C                                              +------------+
object                                                | RTTI for C |
    0 - struct B                            +-------> +------------+
    0 -   struct A                          |         |   C::f0()  |
    0 -     vptr_A -------------------------+         +------------+
    8 -     int ax                                    |   B::f1()  |
   12 -   int bx                                      +------------+
   16 - int cx                                        |   C::f2()  |
sizeof(C): 24    align: 8                             +------------+
```

### 多继承内存模型

类型`C`同时继承了两个独立的基类`A`和`B`， 它们的定义关系如下：

```cpp
struct A
{
    int ax;
    virtual void f0() {}
};

struct B
{
    int bx;
    virtual void f1() {}
};

struct C : public A, public B
{
    int cx;
    void f0() override {}
    void f1() override {}
};
```

与单链继承不同，由于`A`和`B`完全独立，它们的虚函数没有顺序关系，即`f0`和`f1`有着相同对虚表起始位置的偏移量，不可以顺序排布。 并且`A`和`B`中的成员变量也是无关的，因此基类间也不具有包含关系。这使得`A`和`B`在`C`中必须要处于两个不相交的区域中**。**同时需要有两个虚指针分别对它们虚函数进行索引。

其内存布局如下所示：

```text
                                                C Vtable (7 entities)
                                                +--------------------+
struct C                                        | offset_to_top (0)  |
object                                          +--------------------+
    0 - struct A (primary base)                 |     RTTI for C     |
    0 -   vptr_A -----------------------------> +--------------------+       
    8 -   int ax                                |       C::f0()      |
   16 - struct B                                +--------------------+
   16 -   vptr_B ----------------------+        |       C::f1()      |
   24 -   int bx                       |        +--------------------+
   28 - int cx                         |        | offset_to_top (-16)|
sizeof(C): 32    align: 8              |        +--------------------+
                                       |        |     RTTI for C     |
                                       +------> +--------------------+
                                                |    Thunk C::f1()   |
                                                +--------------------+
```

出现了两个“新”的实体，一个是`offset_to_top`，另一个是`Thunk`。

**offset\_to\_top:** 在多继承中，由于不同的基类起点可能处于不同的位置，因此当需要将它们转化为实际类型时，`this`指针的偏移量也不相同。由于实际类型在编译时是未知的，这要求偏移量必须能够在运行时获取。实体`offset_to_top`表示的就是实际类型起始地址到当前这个形式类型起始地址的偏移量。在向上动态转换到实际类型时，让`this`指针加上这个偏移量即可得到实际类型的地址。需要注意的是，由于一个类型即可以被单继承，也可以被多继承，因此即使只有单继承，实体`offset_to_top`也会存在于每一个多态类型之中。

**Thunk:**而实体`Thunk`又是什么呢？如果不考虑这个`Thunk`，这里应该存放函数`C::f1()`的地址。然而，dump虚表可以看到，`Thunk C::f1()`和`C::f1()`的地址并不一样。

弄清楚`Thunk`是什么，首先要注意到，如果一个类型`B` 的引用持有了实际类型为`C`的变量，这个引用的起始地址在`C+16`处。当它调用由类型`C`重写的函数`f1()`时，如果直接使用`this`指针调用`C::f1()`会由于`this`指针的地址多出`16`字节的偏移量导致错误。 因此在调用之前，`this`指针必须要被调整至正确的位置 。这里的`Thunk`起到的就是这个作用：首先将`this` 指针调整到正确的位置，即减少`16`字节偏移量，然后再去调用函数`C::f1()`。

### 虚继承的内存模型

**菱形继承内存模型**

四个类型`A`，`B`，`C`和`D`的继承关系如下所示：

```cpp
struct A
{
    int ax;
    virtual void f0() {}
    virtual void bar() {}
};

struct B : virtual public A           /****************************/
{                                     /*                          */
    int bx;                           /*             A            */
    void f0() override {}             /*           v/ \v          */
};                                    /*           /   \          */
                                      /*          B     C         */
struct C : virtual public A           /*           \   /          */
{                                     /*            \ /           */
    int cx;                           /*             D            */
    virtual void f1() {}              /*                          */
};                                    /****************************/


struct D : public B, public C
{
    int dx;
    void f0() override {}
};
```

首先对类型`A`的内存模型进行分析。由于虚继承影响的是子类，不会对父类造成影响，因此`A`的内存布局和虚表都没有改变。

```text
                                                   A VTable
                                                   +------------------+
                                                   | offset_to_top(0) |
struct A                                           +------------------+
 object                                            |    RTTI for A    |
     0 - vptr_A -------------------------------->  +------------------+
     8 - int ax                                    |      A::f0()     |
sizeof(A): 16    align: 8                          +------------------+
                                                   |      A::bar()    |
                                                   +------------------+
```

类型`B`类和类型`C`没有本质的区别，因此只分析类型`B`。下图为类型`B`的内存模型：

```text
                                          B VTable
                                          +---------------------+
                                          |   vbase_offset(16)  |
                                          +---------------------+
                                          |   offset_to_top(0)  |
struct B                                  +---------------------+
object                                    |      RTTI for B     |
    0 - vptr_B -------------------------> +---------------------+
    8 - int bx                            |       B::f0()       |
   16 - struct A                          +---------------------+
   16 -   vptr_A --------------+          |   vcall_offset(0)   |x--------+
   24 -   int ax               |          +---------------------+         |
                               |          |   vcall_offset(-16) |o----+   |
                               |          +---------------------+     |   |
                               |          |  offset_to_top(-16) |     |   |
                               |          +---------------------+     |   |
                               |          |      RTTI for B     |     |   |
                               +--------> +---------------------+     |   |
                                          |     Thunk B::f0()   |o----+   |
                                          +---------------------+         |
                                          |       A::bar()      |x--------+
                                          +---------------------+
```

对于形式类型为`B`的引用，在编译时，无法确定它的基类`A`它在内存中的偏移量。 因此，需要在虚表中额外再提供一个实体，表明运行时它的基类所在的位置，这个实体称为`vbase_offset`，位于`offset_to_top`上方。

除此之外，如果在`B`中调用`A`声明且`B`没有重写的函数，由于`A`的偏移量无法在编译时确定，而这些函数的调用由必须在`A`的偏移量确定之后进行， 因此这些函数的调用相当于使用`A`的引用调用。也因此，当使用虚基类`A`的引用调用重载函数时 ，每一个函数对`this`指针的偏移量调整都可能不同，它们被记录在镜像位置的`vcall_offset`中。例如，调用`A::bar()`时，`this`指针指向的是`vptr_A`，正是函数所属的类`A`的位置，因此不需要调整，即`vcall_offset(0)`；而`B::f0()`是由类型`B`实现的， 因此需要将`this`指针向前调整`16`字节。

对于类型`D`，它的虚表更为复杂，但虚表中的实体我们都已熟悉。 以下为`D`的内存模型：

```text
                                          D VTable
                                          +---------------------+
                                          |   vbase_offset(32)  |
                                          +---------------------+
struct D                                  |   offset_to_top(0)  |
object                                    +---------------------+
    0 - struct B (primary base)           |      RTTI for D     |
    0 -   vptr_B  ----------------------> +---------------------+
    8 -   int bx                          |       D::f0()       |
   16 - struct C                          +---------------------+
   16 -   vptr_C  ------------------+     |   vbase_offset(16)  |
   24 -   int cx                    |     +---------------------+
   28 - int dx                      |     |  offset_to_top(-16) |
   32 - struct A (virtual base)     |     +---------------------+
   32 -   vptr_A --------------+    |     |      RTTI for D     |
   40 -   int ax               |    +---> +---------------------+
sizeof(D): 48    align: 8      |          |       D::f0()       |
                               |          +---------------------+
                               |          |   vcall_offset(0)   |x--------+
                               |          +---------------------+         |
                               |          |   vcall_offset(-32) |o----+   |
                               |          +---------------------+     |   |
                               |          |  offset_to_top(-32) |     |   |
                               |          +---------------------+     |   |
                               |          |      RTTI for D     |     |   |
                               +--------> +---------------------+     |   |
                                          |     Thunk D::f0()   |o----+   |
                                          +---------------------+         |
                                          |       A::bar()      |x--------+
                                          +---------------------+     
```

