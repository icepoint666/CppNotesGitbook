# volatile

参考：[https://www.zhihu.com/question/388121842/answer/1195382979](https://www.zhihu.com/question/388121842/answer/1195382979)

（要求知识：汇编语言，内存模型，编译器的常量优化）

* volatile到底作用是干嘛的
* volatile在多线程时代被开发出新的作用
* 关于volatile一些误导的纠正，以及一些说法的理解

**volatile本质是一种类型说明符，与const地位差不多可以应用到任何变量**

**volatile告诉编译器不要对这个变量执行“常量优化”**

## volatile到底是干嘛的

**1.本质原因：**跟读写内存有关

读写内存一次的代价非常昂贵，一次访存同时又cache未命中引起的开销是70个时钟周期，而读取寄存器几乎没有开销。

**2.编译器的“常量优化”：优化内存读写为寄存器读写**

编译器必然倾向于“尽量压缩掉所有不必要的内存访问指令”。这个技术被称为“常量优化”

其实就是：

**观察一段子程序，尽量把‘内存变量的读写’去掉，替换为‘只往寄存器加载一次，然后一直用寄存器内容’**

常量优化”说白了是一种“相信X这个变量在我控制之下，因此没必要执行那么多‘多余的读写’”

**“常量优化”之所以叫做常量优化**，是说这个优化是针对常量才不会错误的，如果量是一个可能发生变化的（volatile）那么常量优化就很有可能出问题

所以**常量优化配合C++ const发挥使用：**

* 无const修饰的变量，传址到另一个函数中，那么这个变量很可能就会被这个函数修改；那么当函数执行返回后，你就不得不重新读一下内存中这个变量的值，这样才能保证寄存器里面的值是最新的。
* const关键字相当于告诉编译器，这个函数并不会修改这个被声明为const的引用变量；所以无需在本函数执行返回后、强制调用者重新加载新值。（声明：func\(const &arg1\)\)

**传参数时出现const修饰，编译器会加上“常量优化”**

另外一般也出现在循环中避免去每轮都load内存数据到寄存器（LOAD x to EAX）

**3.优化会引起的问题**（最初问题）

举例：某些CPU上，外设和内存是统一编址的。比如你把指针p指向内存位置100H，在intel CPU上这是访问内存；但在其它CPU上，这可能是读写地址编码为100H的那个外设的内容（比如网卡）。

于是，当它是内存时，只在开头读一次到寄存器、之后一直操作寄存器是正确的优化；但如果它是外设……

**4.volatile关键字**：

告诉编译器，这个变量的内容随时可能因不明原因改变，因此**不要对它执行常量优化。**

## volatile在多线程时代被开发出新的作用

**1.多线程中如果存在常量优化存在的问题**

多线程允许一个程序内部同时存在多个执行绪；这时候，哪怕变量指向内存，它的内容也可能随时改变了——只要它被共享给另一个线程。

为了图方便，人们直接“挪用”了volatile关键字——这个变量的内容随时可能改变，因此不要对它做常量优化。

**2.关键示例：常量优化导致多线程“锁”出现问题的例子**

对这段代码：

```cpp
for(循环1000遍) {
    lock();
    x++;
    unlock();
}
```

正常生成的、无优化的汇编伪代码应该是：

```bash
loop: //循环1000遍
CALL lock
LOAD x to EAX //每次循环都要从内存载入x值
inc EAX
SAVE EAX to x //每次循环都要把x值写回内存
//判断循环次数是否足够
... //代码略
JNZ loop //返回loop标签，重复执行如上动作
```

很明显，循环1000遍，那么就要执行1000次LOAD x to EAX 和 SAVE EAX to x；期间执行权变动可能引起cache失效，每次cache失效都需要至少70个时钟周期访问DDR……

注意，x86汇编支持在指令中访问内存，并不需要像某些RISC机一样使用独立的load/save指令访存。但拆开写有助于理解这里的实际执行过程，因此这里我把它写成了三条指令。

一旦打开优化，编译器会优化成这样：

```text
LOAD x to EAX //在整个函数中仅载入x值一次

loop: //循环1000遍
CALL lock
inc EAX
//判断循环次数是否足够
... //代码略
JNZ loop //返回loop标签，重复执行如上动作

SAVE EAX to x //不再读写x之后、函数返回之前，把x写回内存
```

在循环开始之前执行LOAD x to EAX把x内容载入EAX，然后一直操纵EAX；直到循环结束、线程返回前，这才调用SAVE EAX to x，把EAX内容写回x。

显然，如此一来，当某个单线程进程执行这段循环时，它只会操纵自己那个执行现场的EAX；不仅少执行了1998条访存指令，还可以借助现代CPU海量的寄存器/寄存器窗口，获得极致的执行效率。

**问题出现**在，把这段代码丢线程里执行时，里面的lock/unlock其实是没有实际作用的。因为两个线程都仅仅读写了一次内存中的x，之后的执行完全是各做各的。这样显然是要出大事的。

换句话说，**常量优化错误的删除了循环中的访存指令**，这才是bug出现的原因。

## 关于volatile一些误导的纠正，以及一些说法的理解

1. volatile不等于原子性：

   volatile的意思是“可变”，但实际上，对一个volatile变量的访问指令未必是原子的；**volatile仅保证了“每次都从内存取数据”**，并不能保证数据安全（无法避免脏读/脏写）

   你必须自己想办法保护共享数据、确保对它们访问的原子性。

2. 既然volatile保证不了数据安全，我用锁保护它总行了吧，但是volatile的作用不会被代替，并不能删去

   哪怕用了锁，volatile仍然有用。它的作用是阻止编译器的常量优化。多线程访问的数据的确不能常量优化，所以你还必须写上它——换句话说，需要阻止常量优化的地方，你仍然需要自己明确声明。

3. 利用volatile避免过度优化”这个说法，又是一个典型的、更浅薄的错误理解——**volatile的作用很精确，就是阻止常量优化**；如果编译器的常量优化没问题，用它就是典型的“负优化”；如果编译器真优化出了问题，用它也并不能阻止其他方面的优化

**总结：**

​ volatile 关键字是一种**类型修饰符**，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。

​ volatile 关键字声明的变量，**每次访问时都必须从内存中取出值**（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）

​ const 可以是 volatile （如**只读的状态寄存器**）

​ 指针可以是 volatile

