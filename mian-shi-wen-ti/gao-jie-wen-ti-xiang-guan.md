# 高阶问题相关

### 1.在多线程和大量并发环境下，如果有一个平均运行一百万次出现一次的bug， 你如何调试这个bug

（1）首先需要重现这个Bug（确定触发这个Bug的输入数据/内存状态等信息是什么）

**压测实现：**其实**100万分之一的几率并不算很低**。一个繁忙一点的服务，每秒一万个请求是很正常的（如果业务简单，还能更高）。所以百万分之一的复现概率，相当于在压力测试下几分钟就能出一次了。

既然几分钟就能复现，那就在测试环境里压就好了，想怎么改就怎么改，想怎么打log就怎么打log。 假定测试环境的**压测真的没出来，真的线上出现这样的问题**（例如说压测的用例没有覆盖到）。首先考虑的是**回滚服务到旧版**，以确保正常业务不出问题。

然后在线上环境提取某台机，用类似tcpcopy这样的软件**导一份数据到测试环境**中，来测试这个有问题的版本。

（也有类似复现的工具，例如TimeMachine，这工具需要收费，这个工具就可以记录所有程序运行时重现的必要信息，遇到错误的时候保存一个文件）

（2）实现出来后真正分析bug

如果能**core dump**的话相对好办一些，因为可以从core dump大概能看出或者猜出一些东西来。而如果并不core dump，而只是导致数据错乱的话，那就要做数据出入口的校验等

**打log**：在各顶级模块的**入口出口打log**，定位发生bug时所在的模块，然后**逐步收敛**。 确定这些模块以及关联影响的模块，单独提取这些模块出来，进行测试或者code review，最终确定问题。

（3）解决，分析解决成本，有些BUG我们是知道，但是解决太麻烦了，影响也不大，就放着。



### 2.有一个类指针，指向类实例化的对象，在这个对象程序的运行过程中，程序崩溃了，后来发现是这个类指针的虚函数表被破坏了，现在如何定位这个问题

（题目意思①可能是如果有一个bug是指针的虚函数表破坏了，但是程序员不知道哪里的错误，怎么能定位到这个问题是发生在虚函数表被破坏的，意思②是如果已知是类指针虚函数表被破坏了，怎么定位到哪个类那个对象并解决） 

vtable是compiler define的，在 Linux 下 GCC 4.9 的实现就是放在read only 段 .rodata

所以class 的虚函数表被破坏是不可能的，因为这个 vtable 放在 rodata 区，是只读的。修改 vtable 会导致 **segment fault**，这样拿 **coredump** 一看就知道哪条语句在干坏事。

class object 里的 **vptr 被修改**倒是有可能。这类**bug**一般都涉及越界操作。 大多数都是可以通过静态code review解决的。既然知道是那个类，盯着用到这些类的实例的地方就行（包括这些类实例的前后几个对象，因为有可能是它们越界），一些工具，例如valgrind可能有帮助

如果可能是**memory corruption**造成破坏，可以设置"watch point"，和break point类似，就是监控内存的feature

