# 基础问题相关

### 1.为什么头文件里要加\#ifndef \#define

**\#ifndef是if not define 目的防止头文件被重复包含**

```cpp
#ifndef HEADERFILE_H
#define HEADERFILE_H
...
#endif
```

回答思路：

1. 一个源文件或者一个头文件 **\#include指令**是发生在**预编译阶段**
2. **预编译\(gcc -i \)**会把这个头文件的大段代码复制到预编译代码文件中

   举个例子：一个写的头文件有几百行，就放到预编译文件中

3. 假如源文件`#include a.h`和`#include b.h`，其中`a.h`也`#include b.h`

   不加\#ifndef 那么源文件预编译就会有两份b.h的预编译代码部分

   就是为了防止重复多余的包含

### 2. C/C++语言头文件的意义是什么

1. **头文件保证编译单元的独立性**，有利于对各个编译单元并行编译、做增量编译，没有相互依赖。

   如果一个头文件对应的源文件内部的实现有更改，只要调用接口保持不变的话，那只要把调用所需的编译单元**重新编译**，再把新目标文件**重新链接进二进制**就行了，本身调用者的这个文件是不用重新编译的

2. **支持闭源发布，作为导出的接口：**只要你发布**头文件**和一个**二进制的库文件**给你库的使用者就够了。

   C/C++ 库的二进制里是没有任何对类（结构体）的排布信息和对函数的调用规则描述的，这个描述的工作就是头文件做了。好处就是二进制库文件以及链接了库的程序里不需要记录任何的元信息，体积小，而且被逆向的难度相对困难。

3. **泛型编程中广泛使用**：C++ 的头文件中就不止有传统的声明语句，也可以给出函数的实现了。这就出现了不同于传统的静态库和动态库的第三种库 —— head-only library（唯头文件库），特点是使用方便，还有利于编译器做优化。

### 3.重载过程的解析

当调用函数时，编译器根据实参的类型和形参的匹配情况，选择一个确定的重载版本，这个过程叫**重载解析**。

实参的类型和形参的匹配情况有三种：

* 1、编译器找到与实参最佳的匹配函数，编译器将生成调用代码。
* 2、编译找不到匹配函数，编译器将给出错误信息。 
* 3、编译器找到多个匹配函数，但没有一个最佳的，这种错误叫二义性。

### 4.默认形参

几个原则：

* 如果形参只有一部分设置了默认形参，在某个提供了默认值的参数后面，所有的参数都必须提供默认值。 
* 函数的默认形参是在**编译阶段确定的**，因此只能使用常量、常量表达式、全局变量数据作为默认值。 提问:如果函数的声明和定义需要分开，那么默认形参设置在声明、定义，还是声明定义都需要设置？ 
* 默认形参会对函数重载造成影响\(二义性\)，设置默认形参时一定要慎重。

### 5.class和struct的区别？

* class的默认继承和访问权限是private，struct的默认继承和访问权限是public
* class能做模板的参数，struct不行。‘

### 6.智能指针与常规指针的一些区别

* 当一个常规指针离开它的作用域时，只有该指针所占用的空间会被释放，而它指向的内存空间能否被释放就不一定了，在一些特殊情况（人为、业务逻辑特殊）free或delete没有执行，就会形成内存泄漏。
* 智能指针是一个封装了常规指针的类类型对象，当它离开作用域时，它的析构函数会自动执行，它的析构函数会负责释放常规指针所指向的动态内存
* 一个对象**只能使用一个智能指针来指向（unique\_ptr?\)**，而常规指针可以指向多次
* 智能指针的赋值操作需要经过拷贝构造和赋值构造特殊处理（深拷贝）

### 7.如何用C++设计一个不能被继承的类。

构造函数或析构函数为私有函数，该类是无法被继承的

### 8.list和vector有什么区别？

vector拥有一段连续的内存空间，因此支持随机存取，如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector。

list拥有一段不连续的内存空间，因此不支持随机存取，如果需要大量的插入和删除，而不关心随即存取，则应使用list。

### 9.如何定义一个只能在堆上（栈上）生成对象的类？

[设计一个只能在堆上或栈上实例化的类](http://www.cnblogs.com/luxiaoxun/archive/2012/08/03/2621827.html)

**定义一个只能在堆上生成的类**

方法：将**析构函数设置为私有，**将析构函数定义为private，在栈上不能自动调用析构函数，只能手动调用。

原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。

**定义一个只能在堆上生成的类**

方法：将 **new 和 delete 重载为私有，**将函数operator new和operator delete定义为private

原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。

### 10.多重类构造和析构的顺序

先调用基类的构造函数，在调用派生类的构造函数

先构造的后析构，后构造的先析构

### 11.防止指针的越界使用

必须让指针指向一个有效的内存地址

* 1 防止数组越界 
* 2 防止向一块内存中拷贝过多的内容 
* 3 防止使用空指针 
* 4 防止改变const修改的指针 
* 5 防止改变指向静态存储区的内容 
* 6 防止两次释放一个指针 
* 7 防止使用野指针

### 12.什么是指针退化

如果用一个数组作为函数入参 比如，那么**数组退化为指针，sizeof只有指针的长度** 

```cpp
void fun(char a[100]) { 
    cout<<sizeof(a)<<endl; 
}
```

### 13.堆和栈上的指针有什么不同

指针所指向的这块内存是在哪里分配的,在堆上称为堆上的指针,在栈上为栈上的指针. 

在堆上的指针,可以保存在全局数据结构中,供不同函数使用访问同一块内存. 

在栈上的指针,在函数退出后,该内存即不可访问.

### 14.智能指针的原理

智能指针：实际指行为类似于指针的类对象 ，它的一种通用实现方法是采用引用计数的方法。

* 1.智能指针将一个计数器与类指向的对象相关联，引用计数跟踪共有多少个类对象共享同一指针。 
* 2.每次创建类的新对象时，初始化指针并将引用计数置为1； 
* 3.当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数； 
* 4.对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；这是因为左侧的指针指向了右侧指针所指向的对象，因此右指针所指向的对象的引用计数+1；
*  5.调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。 

### 15.override与overload特性上区别

override（重写）

* 1、方法名、参数、返回值相同。 
* 2、子类方法不能缩小父类方法的访问权限。
* 3、子类方法不能抛出比父类方法更多的异常\(但子类方法可以不抛出异常\)。
* 4、存在于父类和子类之间。
* 5、方法被定义为final不能被重写。 

overload（重载） 

* 1、参数类型、个数、顺序至少有一个不相同。
* 2、不能重载只有返回值不同的方法名。
* 3、存在于父类和子类、同类中。

### 16.指针的四要素

* 1指针变量,表示一个内存地址,通常为逻辑地址,与实际的物理地址还有一个映射关系. 
* 2指针变量的长度,在WIN32下为四个字节
* 3指针指向的变量 该内存地址空间下存放的变量,具体内容可能是各种类型的变量
* 4指针指向的变量的长度,以该内存地址空间开始的内存空间大小.

### **17.编译型和解释型语言区别**

编程语言没有编译型和解释型的区别，只能说某个语言常见的执行方式为_编译成新代码执行_或_解释器解释执行_ 编译器的输入是A语言的源代码，而输出是B语言；比如C++，被编译成汇编语言； 解释器的输入是A语言的源代码，它直接执行A语言；一般解释器的内部实现是一个编译器加一个虚拟机，编译器把输入语言编译成中间语言，虚拟机直接执行中间语言。

