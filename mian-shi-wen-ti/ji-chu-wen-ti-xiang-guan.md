# 基础问题相关

### 1.为什么头文件里要加\#ifndef \#define

**\#ifndef是if not define 目的防止头文件被重复包含**

```cpp
#ifndef HEADERFILE_H
#define HEADERFILE_H
...
#endif
```

回答思路：

1. 一个源文件或者一个头文件 **\#include指令**是发生在**预编译阶段**
2. **预编译\(gcc -i \)**会把这个头文件的大段代码复制到预编译代码文件中

   举个例子：一个写的头文件有几百行，就放到预编译文件中

3. 假如源文件`#include a.h`和`#include b.h`，其中`a.h`也`#include b.h`

   不加\#ifndef 那么源文件预编译就会有两份b.h的预编译代码部分

   就是为了防止重复多余的包含

### 2. C/C++语言头文件的意义是什么

1. **头文件保证编译单元的独立性**，有利于对各个编译单元并行编译、做增量编译，没有相互依赖。

   如果一个头文件对应的源文件内部的实现有更改，只要调用接口保持不变的话，那只要把调用所需的编译单元**重新编译**，再把新目标文件**重新链接进二进制**就行了，本身调用者的这个文件是不用重新编译的

2. **支持闭源发布，作为导出的接口：**只要你发布**头文件**和一个**二进制的库文件**给你库的使用者就够了。

   C/C++ 库的二进制里是没有任何对类（结构体）的排布信息和对函数的调用规则描述的，这个描述的工作就是头文件做了。好处就是二进制库文件以及链接了库的程序里不需要记录任何的元信息，体积小，而且被逆向的难度相对困难。

3. **泛型编程中广泛使用**：C++ 的头文件中就不止有传统的声明语句，也可以给出函数的实现了。这就出现了不同于传统的静态库和动态库的第三种库 —— head-only library（唯头文件库），特点是使用方便，还有利于编译器做优化。

### 3.重载过程的解析

当调用函数时，编译器根据实参的类型和形参的匹配情况，选择一个确定的重载版本，这个过程叫**重载解析**。

实参的类型和形参的匹配情况有三种：

* 1、编译器找到与实参最佳的匹配函数，编译器将生成调用代码。
* 2、编译找不到匹配函数，编译器将给出错误信息。 
* 3、编译器找到多个匹配函数，但没有一个最佳的，这种错误叫二义性。

### 4.默认形参

几个原则：

* 如果形参只有一部分设置了默认形参，在某个提供了默认值的参数后面，所有的参数都必须提供默认值。 
* 函数的默认形参是在**编译阶段确定的**，因此只能使用常量、常量表达式、全局变量数据作为默认值。 提问:如果函数的声明和定义需要分开，那么默认形参设置在声明、定义，还是声明定义都需要设置？ 
* 默认形参会对函数重载造成影响\(二义性\)，设置默认形参时一定要慎重。

### 5.class和struct的区别？

* class的默认继承和访问权限是private，struct的默认继承和访问权限是public
* class能做模板的参数，struct不行。‘

### 6.智能指针与常规指针的一些区别

* 当一个常规指针离开它的作用域时，只有该指针所占用的空间会被释放，而它指向的内存空间能否被释放就不一定了，在一些特殊情况（人为、业务逻辑特殊）free或delete没有执行，就会形成内存泄漏。
* 智能指针是一个封装了常规指针的类类型对象，当它离开作用域时，它的析构函数会自动执行，它的析构函数会负责释放常规指针所指向的动态内存
* 一个对象**只能使用一个智能指针来指向（unique\_ptr?\)**，而常规指针可以指向多次
* 智能指针的赋值操作需要经过拷贝构造和赋值构造特殊处理（深拷贝）





