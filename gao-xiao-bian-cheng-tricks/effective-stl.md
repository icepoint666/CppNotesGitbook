# Effective STL

### 0.STL分类

#### 序列容器 与 关联容器

序列：vector， string， deque，list，slist（单向链表，非标准）

关联：map，multimap，set，multiset，hashset, hashmultiset...

#### 连续内存容器 与 基于节点容器

连续内存容器，contiguous memory container

* 元素存放在一块或者多块内存中，每块内存中存有多个元素
* 当有新元素插入或者元素删除的时候，同一块内存中的其他元素都要向前向后移动，为了腾出空间
* vector， deque，string
* 弊端：这样会影响效率，并且也会影响异常安全性

基于节点的容器，node-based memory container

* 在每一个动态分配的内存块中只存放一个元素，容器中元素的插入与删除只影响当前节点的指针，不会影响节点内容本身
* list，slist，标准的哈希容器（平衡树实现的），非标准的哈希容器



#### 迭代器的五种类型

五种迭代类型有了解哪些

* 输入迭代器 input iterator 也就是只读迭代器
  * 每个遍历到的位置只能被读取一次
* 输出迭代器 output iterator 类似 只写迭代器
* 前向迭代器 兼顾输入输出迭代器的功能
  * 可以对同一位置重复的读或者写
  * 前向迭代器不支持`—operator`也就是只能前向移动
* 双向迭代器 类似于前面的 支持前向移动与后向移动
  * 示例：list迭代器就是这样
* 随机访问迭代器 random access iterator
  * 拥有双向迭代器的所有功能，而且还提供了迭代器的算数，跳跃等
  * 示例：deque vector string迭代器就是这样

### 1.STL容器的选取原则

关乎到元素排序情况，迭代器相关，元素布局，C的兼容性，查找速度，事务语义，异常行为，效率容器复杂度

* 需要在任意位置插入元素，那么就需要序列容器
* 如果不关心容器中的元素是如何排序，那么哈希容器是一个可选择的方案（哈希容器本身不属于C++标准的一部分）
* 发生元素的插入或者删除时，尽量避免连续内存的容器
* 容器中数据的布局是否需要跟C兼容，如果需要的话，那么只能使用vector
* 元素的查找速度是否很关键，如果是的话，那么就要选用哈希容器
* 容器内部使用了引入计数reference counting技术是否介意，如果是的话，就要避免使用string与rope，因为这两种容器都使用引用计数去实现，string可以替换为vector&lt;char&gt;
* 插入和删除操作需要事务语义吗
  * 也就是说如果插入或者删除操作失败的话，需要具备会滚能力吗
  * 如果需要事务语义，那么就要使用基于节点的容器，例如list
  * 那些需要编写异常安全的代码，事务语义很重要
* 是否需要尽量减少迭代器/引用/指针失效次数
  * 基于节点的容器，插入和删除操作是不会使迭代器失效的
* deque的一个特殊性
  * 作为序列容器，迭代器是随机访问类型，而且只要没有删除操作发生，且插入操作只发生在容器的末尾，迭代器可能会变成无效，但是指针和引用不会无效
  * 只有deque具有这样的特性：迭代器无效，但是指针和引用不会无效



